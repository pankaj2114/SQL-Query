CREATE DATABASE sample;
Alter database sample modify name = sample1;
use sample1;
go
Create table Gender (
Id int primary key,
Gender nvarchar(50) not null
)

Create Table Person(
Id int not null primary key,
Name nvarchar (50),
Email nvarchar (50),
GenderId int foreign key references Gender (id)
)
Insert into Gender (Id,Gender) 
Values
(1,'Male'),
(2,'Female'),
(3,'Not Confirmed')

Insert into Person(Id,Name,Email,GenderId)
Values
(1,'Pankaj','pa@gmail.com',1),
(2,'Aman','am@gmail.com',2),
(3,'Amar','amar@gmail.com',1),
(4,'Shalu','sha@gmail.com',3),
(5,'Sanjay','san@gmail.com',2)

Insert into Person(Id,Name,Email,GenderId)
Values (6,'Hello','hello@gmail.com',null)

/*adding key  constraint*/
Alter table Person
Add Constraint DF_Person_Genderid
Default 3 for GenderId

/*Deleting key constraint*/
Alter table Person 
Drop Constraint DF_Person_Genderid

delete from Person where id = 4
select * from Person

Alter table Person
Add Age int null

 /*Adding Check constraint*/
Alter table Person
Add Constraint Check_age check (age > 0 And age < 150 or Age Is Null)

insert into Person values (4,'sara','sa@gmail.com',2,90)

/*droping constraint*/
Alter table Person 
Drop Constraint Check_age



/*New Table from here*/


/*Identity column -> An identity column, also known as an auto-incrementing or serial column*/
Create Table Person1
(
personId int primary key identity(1,1),
Name nvarchar(50)
)

Insert into Person1 
values 
('Pankaj'),
('Ankit'),
('Aman')

select * from Person1

Delete from Person1 where personId = 1

/*explicitly giving id*/
Insert into Person1 (personId,name)
values 
(1,'shalu')  /*Cannot insert explicit value for identity column in table 'Person1' when IDENTITY_INSERT is set to OFF.*/
/*On identity_Insert to insert explicitly*/
Set Identity_Insert Person1 ON

Insert into Person1 (personId,name)
values 
(1,'shalu')
/*off identity_Insert if you have no need to insert explicitly*/
Set Identity_Insert Person1 OFF

/*Reseting identity*/
DBCC CHECKIDENT (Person1, Reseed,0)

delete from Person1

Insert into Person1 
values 
('shalini')





/**New Table from here*/
Create Table Test1
(
Id int Identity(1,1),
Value nvarchar(20)
)

Create Table Test2
(
Id int Identity(1,1),
Value nvarchar(20)
)

insert into test1
values
('Aman'),
('Sman')

select * from Test1
/*how to get Last generated identity column value*/
Select SCOPE_IDENTITY() /*It will return current index or id that is generated by auto increament*/
/*Second way OF Above query*/
Select @@IDENTITY




/*Now working with Person Table*/

/**Adding unique key constraint in Person table email column*/
select * from Person  

Alter Table Person
Add Constraint UQ_Person_Email Unique (Email)

insert into Person Values (8,'Hello','he@a.com',1,50)
                                                       /*due to same Email */
insert into Person Values (9,'Hello','he@a.com',1,50) /*Violation of UNIQUE KEY constraint 'UQ_Person_Email'. Cannot insert duplicate key in object 'dbo.Person'. The duplicate key value is (he@a.com).*/


/**using select with different keyword*/
select * from Person

select distinct genderId from person

select distinct genderId,Email from person

Select * from Person Where age IN (10,50,90,null)

Select * from Person Where age BETWEEN 10 AND 100

/*Order By*/
Select * from Person Order By Id desc;

Select * from Person Order By Id  /*By default Accending Order*/

/*To get top N or N Percent Records*/
Select Top 3 * from Person

Select Top 3 Percent * from Person

select top 50 Percent * From Person Order By Id DESC /*Top 50% Higher Id Record it can be same in salary */


/*Group By =>  used to group rows that have the same values in one or more columns*/
/*Group By using with Aggregate Function*/
delete from Person

Alter Table Person
Add Salary int

Alter Table Person
Add City nvarchar(50)

insert into Person (id,Name ,Email,GenderId, age, Salary,City)
Values 
(1,'Hello','he@a.com',1,50,50000,'London'),
(2,'Mello','me@a.com',2,30,40000,'London'),
(3,'Sello','se@a.com',1,22,90000,'America'),
(4,'Lello','le@a.com',null,20,30000,'America'),
(5,'Yello','ye@a.com',2,30,80000,'India'),
(6,'Nello','ne@a.com',1,80,10000,'India')

select * from Person
/*aggregate Functions => 5*/
select sum(salary) as Total_Salary from Person 

select Min(salary) as Min_Salary from Person 

select Max(salary) as Max_Salary from Person 

select Avg(salary) as Avg_salary from Person 

select Count(salary) as Total_Emp from Person 

Select City as city,Sum(salary) as City_Total_Sal from Person Group By City

Select City,Count(Id) as Total_Employee From Person Group By City having City  = 'India'

Select City,Genderid,Count(Id) as [Total Employee] From Person Group By City,GenderId Having GenderId  = 1



/*Joins => Cross Join, Inner Join, Right Outer Join,Left Outer Join, Full Outer Join*/

--Syntax
/*
Select      ColumnName
From        Left Table Name
Join Type    Right table name
on           join Condition
*/

Create Table Employee 
(
Id int Identity(1,1),
Name nvarchar(50),
Gender nvarchar(50),
Salary int,
Deptt_Id int Check(deptt_id > 0 and deptt_id < 5 or deptt_id is null)
)

Insert into Employee
Values
('Hello','Male',50000,1),
('Mello','Male',40000,2),
('Sello','Male',30000,3),
('Pello','Female',60000,4),
('Aello','Male',70000,4),
('Tello','Female',10000,3),
('Bello','Male',50000,1),
('Cello','Female',900000,1),
('Lello','Female',100000,null)

select * from Employee

Create Table Department
(
Id int primary key Check(id > 0 and id < 5),
Deptt_Name nvarchar(50),
Location nvarchar(50),
Deptt_Head nvarchar(50)
)

insert into Department
Values
(1,'IT','Noida','Pankaj'),
(2,'Pay Roll','Delhi','Vivek'),
(3,'HR','London','Rachin'),
(4,'Other Department','USA','Mukesh')

select * from Department
--inner join
Select * from Employee 
Inner Join
Department
ON Department.id = Employee.Deptt_id

--left join
Select * from Employee 
Left Outer Join
Department
ON Department.id = Employee.Deptt_id

--Right Join
Select * from Employee 
Right Outer Join
Department
ON Department.id = Employee.Deptt_id

--Full Join
Select * from Employee 
Full Outer Join
Department
ON Department.id = Employee.Deptt_id

--Cross Join
Select * from Employee   -- cross join provide cross of two table.
Cross Join
Department

Select * from Employee 
Left join 
Department 
ON Department.id = Employee.Deptt_id
where Department.id is null

 -- COALESCE FUNCTION => Returns first not null value
 --if name is null then returns gender otherwise will return name
select id, coalesce(name,Gender) as value from employee


-- UNION and UNION ALL
--Union wil Return only Unique Record

Select * from first_Table_Name
UNION
Select * from Second_Table_Name


--Union ALL wil Return both table record with dublicate record

Select * from first_Table_Name
UNION ALL
Select * from Second_Table_Name




--Stored Procedure
--creating stored procedure
CREATE PROCEDURE GetEmpDetail
BEGIN
Select name, gender from Employee
END

--Executing Stored Procedure
GetEmpDetail --or
EXEC GetEmpDetail --or
EXECUTE GetEmpDetail


--STORED PROCEDURE WITH PARAMETER
Create Procedure GetEmpByGenderAndDepartmentId
@Gender nvarchar(20),  --parameter name
@Deptt_Id int          --parameter name
as
Begin
Select name,Gender,Deptt_id from Employee
where 
Gender = @Gender and deptt_id = @deptt_id
End

--executing with passing parameter
GetEmpByGenderAndDepartmentId 'Male',4 
--or
GetEmpByGenderAndDepartmentId @deptt_id = 4, @Gender = 'Male'
--or
GetEmpByGenderAndDepartmentId @Gender = 'Male',@deptt_id = 4


--to view stored procedure
sp_helptext GetEmpByGenderAndDepartmentId

sp_helptext getEmpDetail

--Update stored procedure
Alter Procedure getEmpDetail
AS
Begin
Select name, gender from Employee order by name
End

--executing stored procedure
getEmpDetail


--Encryption of Stored Procedure
Alter Procedure getEmpDetail
With Encryption
AS
Begin
Select name, gender from Employee order by name
End

sp_helptext getEmpDetail



/*Stored procedure with output parameter*/
Create Procedure getEmpDetails
@Gender nvarchar(20),
@empCount int output
AS
Begin
Select @empCount = count(id) from Employee where Gender = @Gender
End

--executing the stored procedure of output parameter
DECLARE @TotalCount int
Execute getEmpDetails 'female', @TotalCount output 
if(@TotalCount is null) print 'Total count is null' --optional
else print 'Total count is not null'                --optional
Print @TotalCount


--creating stored procedure to search by id
create Proc SearchById
@id int
AS
Begin
Select * from Employee where Id = @id
End

--execute procedure => makes reusable and maintainable
Execute SearchById 10


--Build in String functions
Select ASCII('a') --ASCII function
-- Character function => change ascii into character
select CHAR(65)


--Loop 
-- Printing Char from ASCII value 65 to 96 
Declare @Start int
Set @Start = 65
while(@Start < = 90)
Begin
	Print Char(@Start)
	Set @Start = @Start + 1
End


--Upper Case
Select Upper('Pankaj')

--Lower Case
Select LOWER('Pankaj')

--Len Function => finding out the length of String
Select Len('Pankaj')

--Reverse Function
Select REVERSE('Pankaj')

-- LTRIM => to remove the white spaces from left
Select LTRIM('   Pankaj')

-- RTRIM => to remove the white spaces from Right
Select RTRIM('   Pankaj     ')

--LEFT => to get subString from left side
Select Left ('ABCDEF',3)

--Right => to get subString from Right side
Select Right ('ABCDEF',3)

--CHARINDX => To find out the index of a char in String
Select  CHARINDEX ('@','pankaj@gmail.com',1)

--SUBSTRING => To find out the substring from a string\
Select SUBSTRING('pankaj@gmail.com',10,3)  --('string',from index,no. of char)



--DATE TIME Function 
SELECT GETDATE()             --  2023-07-17 18:59:13.497
SELECT CURRENT_TIMESTAMP     --  2023-07-17 19:00:14.470
SELECT SYSDATETIME()         --  2023-07-17 19:01:16.0193901
SELECT GETUTCDATE()          --  2023-07-17 13:32:03.977
SELECT ISDATE('2023-07-17 13:32:03.977')  --RETURN 0 OR 1 Means true or false
SELECT ISDATE('PANKAJ')      -- RETURN 0 because it is not a date

--DAY MONTH YEAR
SELECT DAY(GETDATE())   ---WILL RETURN DATE OF THE DAY
SELECT MONTH(GETDATE())  ---WILL RETURN MONTH LIKE 7 FOR JULY
SELECT YEAR(GETDATE())    --WILL RETURN YEAR 2023

SELECT YEAR('05/25/2001')  --2001 RETURN YEAR
SELECT MONTH('05/25/2001')   --05  RETURN MONTH
SELECT DAY('05/25/2001')    --25   RETURN DATE

SELECT DATEADD(DAY, 20,'03/25/2001')  --IT WILL ADD 20 DAYS IN GIVEN DATE
SELECT DATEADD(MONTH,5,'03/25/2001')
SELECT DATEADD(YEAR,5,'03/25/2001')

SELECT DATEDIFF(DAY,'03/25/2001',GETDATE())   --WILL RETURN YEAR DIFF B/W CURRENT DATE AND GIVEN DATE



--CALCULATING AGE FROM DATE OF BIRTH

CREATE Function ComputeAge(@dob DATETIME)
RETURNS nvarchar(50)
as 
begin
DECLARE @tmpdate DATETIME, @year int, @month int, @day int

SELECT @tmpdate = @dob

SELECT @year = DATEDIFF(YEAR,@tmpdate,GETDATE()) -
								CASE
									WHEN(MONTH(@dob) > MONTH(GETDATE()) OR 
									MONTH(@dob) = MONTH(GETDATE()) AND DAY(@dob) > DAY(GETDATE()) )
									THEN 1 ELSE 0
								END
SELECT @tmpdate = DATEADD(YEAR, @year,@tmpdate)

SELECT @month = DATEDIFF(MONTH,@tmpdate,GETDATE()) -
								CASE
									WHEN(DAY(@dob) > DAY(GETDATE()))
									THEN 1 ELSE 0
								END
SELECT @tmpdate = DATEADD(month, @month, @tmpdate)

SELECT @day = DATEDIFF(DAY, @tmpdate, GETDATE())

DECLARE @Age nvarchar(50)
SET @Age = CAST(@year as nvarchar(4)) + ' Years' + CAST(@month as nvarchar(4)) + ' Months' + CAST(@day as nvarchar(4)) +' Days Old'

return @Age
END

--executing function --> dbo. is important for user define function
select dbo.ComputeAge('03/25/2001')

--CREATING A TABLE AND APPLYING THE ABOVE PROCEDURE ON THAT
CREATE TABLE Transcend
(
EmpName nvarchar(50),
DOB datetime
)

INSERT INTO Transcend 
VALUES
('Pankaj','03/25/2005'),
('Pankaj','03/25/2001'),
('Pankaj','03/25/1999'),
('Pankaj','03/28/1998'),
('Pankaj','03/05/2002')

--applying stored procedure on table -->> dbo.ComputeAge(DOB)
Select EmpName, DOB, dbo.ComputeAge(DOB) as Age from Transcend 


--Mathemetical Function 
SELECT ABS(-256);
SELECT CEILING(252.2)
SELECT FLOOR(15.33)        --15
SELECT FLOOR(-15.332)      ---16
SELECT POWER(2,3)
SELECT SQUARE(9)
SELECT SQRT(9)
SELECT RAND() -- WILL RETURN LESS THAN 1 RANDAM VALUE
SELECT RAND(1)  --ALWAYS RETURN SAME VALUE
SELECT FLOOR(RAND() * 100)   --RETURN B/W 1 TO 100

--FOLLOWING LOOP WILL GENERATAE 10 RANDAM NUMBER FROM 1 TO 100
DECLARE @counter int
SET @counter = 1
WHILE(@counter<=10)
	BEGIN
		PRINT FLOOR(RAND() * 100 )
		SET @counter = @counter + 1
	END




-- USER DEFINE FUNCTION
CREATE FUNCTION calculateAgeYear(@dob DATE)
RETURNS INT
AS 
BEGIN
DECLARE @age INT

SELECT @age = DATEDIFF(YEAR ,@DOB ,GETDATE()) -
								CASE	
									WHEN (MONTH(@dob) > MONTH(GETDATE())) OR
										 (MONTH(@dob) = MONTH(GETDATE()) AND DAY(@dob) > DAY(GETDATE()))
								    THEN 1
									ELSE 0
								END
RETURN @age
END

--CALLING FUNCTION
SELECT dbo.calculateAgeYear('03/25/2001')




--SCALAR USER DEFINE FUNCTION 
-- => THAT TAKES NO PARAMETER BUT RETURN A VALUE OF ANY DATA TYPE

CREATE FUNCTION calculateAgeYear(@dob DATE)
RETURNS INT
AS 
BEGIN
DECLARE @age INT

SELECT @age = DATEDIFF(YEAR ,@DOB ,GETDATE()) -
								CASE	
									WHEN (MONTH(@dob) > MONTH(GETDATE())) OR
										 (MONTH(@dob) = MONTH(GETDATE()) AND DAY(@dob) > DAY(GETDATE()))
								    THEN 1
									ELSE 0
								END
RETURN @age
END

--CALLING FUNCTION
SELECT dbo.calculateAgeYear('03/25/2001')

select empName , dob, dbo.calculateAgeYear(dob) as [age in Year] from Transcend




--Creating and calling INLINE TABLE VALUED FUNCTION
-- It will return table value
CREATE FUNCTION fn_byName(@name nvarchar(20))
RETURNS TABLE
AS                           -- 👇👇👇function inside function
RETURN (select empName , dob, dbo.calculateAgeYear(dob) as [age in Year]
		from Transcend where empName = @name)

--CALLING THE TABLE VALUED FUNCTION
SELECT * from  fn_byName('shalini')





--Multi-statement Table Valued Function
Create Function GetEmployees()
RETURNS @Table TABLE (EmpName nvarchar(20),dob date,age int)
AS
BEGIN
	INSERT INTO @Table
	SELECT EmpName,dob, dbo.calculateAgeYear(dob) as [age in Year] from Transcend
  RETURN
END

--calling function
select * from GetEmployees()






 --Indexes in SQL SERVER
-- cluster and non cluster
-- A Table can have only one cluster index
CREATE TABLE [tblEmployee]
(
[Id] int Primary key,
[Name] nvarchar(50),
[Salary] int,
[Gender] nvarchar(10),
[City] nvarchar(50) 
)

Execute sp_helpindex tblEmployee

INSERT INTO tblEmployee 
VALUES
(3,'Jam',45000,'Male','London'),
(5,'Ham',4000,'Female','New York'),
(2,'Fam',35000,'Male','London'),
(1,'Cam',66000,'Female','India'),
(4,'Yam',25000,'Male','USA'),
(6,'Zam',75000,'Female','Tokyo'),
(8,'Nam',15000,'Male','India'),
(7,'Oam',65000,'Female','USA')

select * from tblEmployee

--Droping default cluster Index do it graphically by right click in object explorer
Drop Index tblEmpoyee.PK__tblEmplo__3214EC07100786CB 

Create Clustered Index IX_tblEmployee_salary
ON tblEmployee (Gender DESC, Salary ASC)






--VIEWS IN SQL SERVER
-- Nothing more than a saved SQL query.
--VIEW can be considered as a virtual table
 select * from Employee
 select * from Department

 Create View VWemployeeDepartment
 as
 Select Employee.Id,Name , gender, salary, deptt_name 
 From Employee
 join Department
 on Employee.Deptt_Id = Department.id

 --executing view
 select * from VWemployeeDepartment
 /*
 --Advantage of views
 -> Reduce time complexity
 -> Make easy to use
 -> Increase security (allow only allowed data)
 
 -- to modify 
 Alter view statement
 --to delete view 
 drop view_Name
 */

 --updating the view -> It will update base table also
 Update VWemployeeDepartment
 Set name = 'Pankaj' where id = 5

 select * from VWemployeeDepartment

 Delete from VWemployeeDepartment  where id = 5

 Insert Into VWemployeeDepartment
 values (1,'shalu','Female', 500000,'IT')

  /*
   View Limitation
  -> You can't pass parameter like Inline function
  -> Updation in view refelect into base table
  -> Order by clause is invalid in views unless Top of FOR XML is also specified
  -> Views cannot be based on temporary tables means changes reflected in base table

  */







  --Triggers
  /*
   ->Triggers in SQL Server are special types of stored procedures 
       ->DML Triggers(Insert,Update, delete)
	         ->After Triggers
			 ->Instead Of Triggers
	   ->DDL Triggers(create, Alter, Drop)
	   ->Logon Trigger
  */
  Create Table tblEmployeeAudit
  (
  id int,
  AuditData nvarchar(70)
  )
 select * from Employee
 select * from tblEmployeeAudit
   

   --trigger for insertion
 Create Trigger tr_emp_for_Insert
 On Employee
 For Insert
 AS
 BEGIN
		Declare @id int
		Select @id = id from inserted
	
		Insert into tblEmployeeAudit
		VALUES (@id,'New Employee With Id = '
		        + cast(@id as nvarchar(5)) + ' is added at ' 
				+ cast(getdate() as nvarchar(20) ))
 END


 insert into Employee
 values
 ('Shalini','Female',50000,3)
 select * from Employee
 select * from tblEmployeeAudit


 --Trigger for deletion
 Create Trigger tr_emp_for_Delete
 On Employee
 For Delete
 AS
 BEGIN
		Declare @id int
		Select @id = id from deleted
	
		Insert into tblEmployeeAudit
		VALUES (@id,'Employee With Id = '
		        + cast(@id as nvarchar(5)) + ' is Deleted at ' 
				+ cast(getdate() as nvarchar(20) ))
 END


 Delete from Employee Where id = 9
 select * from Employee
 select * from tblEmployeeAudit



 Create Trigger tr_emp_for_Update
 ON Employee
 For Update
 as 
 BEGIN
		Declare @id int
		Select @id = id from inserted

		select * from deleted
		select * from inserted
		Insert into tblEmployeeAudit
		VALUES (@id,'Employee With Id = '
		        + cast(@id as nvarchar(5)) + ' is Updated at ' 
				+ cast(getdate() as nvarchar(20) ))
 END

 Update Employee set name = 'Shalu' where id = 6
 
  select * from Employee
 select * from tblEmployeeAudit




 --Instead of Insert Trigger
Select * from Employee
Select * from Department

Create View VWEmp_Deptt
as
select Employee.id,name,gender,deptt_name 
From Employee
join Department
on Employee.deptt_id = Department.id 


Create Trigger tr_VWEmp_Deptt_Insert
on VWEmp_Deptt
Instead of Insert
as 
BEGIN
		Select * from inserted
		select * from deleted

END
 
select * from VWEmp_Deptt
insert into VWEmp_Deptt values (1,'Jan','Female','IT')







--Derived table and common table expression
Select * from Employee
Select * from Department


--Common table expression(CTEs)
/*
(CTE) is another way to define a temporary result set within a SQL query.
It's defined using the WITH clause at the beginning of the main query and can be referenced multiple times within that query. 
Unlike derived tables, CTEs can be used for recursive queries or to simplify complex queries by giving them a name.
*/

--single base table
with Employee_table
as
(
select name ,gender from Employee
)
select * from employee_Table

--with two base table

with emp_table
as
(
	Select Employee.Id,Name , gender, salary, deptt_name 
	From Employee
	join Department
	on Employee.Deptt_Id = Department.id
)
select * from emp_table







--DATABASE NORMALIZATION
--was totally theoretical in Video lecture


--Pivote Operator

--Error Handling

--Transactions


--SubQueries
Create table Products
(
	Id int identity primary key,
	Name nvarchar(50),
	Description nvarchar(250)
)

Create table ProductSales
(
	id int primary key identity,
	ProductId int foreign key references Products(Id),
	UnitPrice Int,
	QuantitySold int
)

Insert into Products 
Values
('TV','52 inch Black color LCD TV'),
('Laptop','14 inch Black color'),
('Desktop','Hp high Performance desktop'),
('Freez','Samsung With high Performance'),
('Cooler','HP with high speed wind'),
('AC','HP with high cold performance')

Insert into ProductSales
Values
(3,450,5),
(3,550,7),
(2,650,4),
(1,750,9),
(4,850,11),
(5,950,6)


Select * from Products
Select * from ProductSales

--sub query to find not saled product 
select id,name,description
from Products
where id not in (select distinct ProductId from ProductSales)

--above nested query by join
select products.Id,name,description
from Products
left join ProductSales
on products.Id = ProductSales.ProductId
where ProductSales.ProductId is null

--sub query to find out the name and total sale qty from both table
select name,
			(select sum(QuantitySold) as TotalSold 
			from ProductSales 
			where Productid = products.id )
from Products



--query to show all the table in database sample 1
Select * from INFORMATION_SCHEMA.tables 



Execute sp_readerrorlog







Create Table tableA 
(
Id int,
Name nvarchar(50),
Gender nvarchar(20)
)


Create Table tableB 
(
Id int,
Name nvarchar(50),
Gender nvarchar(20)
)

Insert into TableA 
Values
(1,'pap','male'),
(2,'sap','male'),
(3,'dap','Female')


Insert into TableB
Values
(1,'pap','male'),
(4,'Dap','male'),
(5,'Tap','Female')

Insert into TableA 
Values
(1,'pap','male')


--It will filter dublicates values
Select * from TableA
Intersect
Select * from TableB

--//it will return dublicate values also 
Select  * from TableA
inner join TableB
on TableA.id = TableB.id

--after using distinct keyword it will also behave like intersect
Select distinct * from TableA
inner join TableB
on TableA.id = TableB.id



Select * from TableA
Union
Select * from TableB



Select * from TableA
Union all
Select * from TableB




Select * from Employee
Select * from Department


--Select Into to take backup of data
Select * into EmployeeBackup From Employee
Select * from EmployeeBackup


--taking backup into different database(making copy of data)
Select * into master.dbo.EmployeeBackupIndifferentDB from Employee
select * from master.dbo.EmployeeBackupIndifferentDB


--different between where and having clause



--Over Clause

select * from Employee


select name,salary , Employee.Gender,genders.total_gender, genders.Avg_salary, genders.Max_salary, genders.Max_salary
from Employee 
inner join
	(select gender,count(gender) as total_gender ,avg(salary) as Avg_salary, max(salary) as Max_salary, min(salary) as Min_salary
	from Employee 
	Group By Gender) as genders
on Employee.gender = genders.gender 


--Over Clause replacement of above complex query
select 
name, salary, gender,
count(gender) over (Partition by gender) as TotalGender,
avg(salary) over (Partition by gender) as AvgSalary,
Max(salary) over (Partition by gender) as MaxSalary,
Min(salary) over (Partition by gender) as MinSalary
from Employee



-- Rank and dense_rank in sql server
Select name, gender, salary,
RANK() OVER (ORDER BY salary DESC) AS [Rank],
DENSE_RANK() OVER (ORDER BY Salary desc) AS DensRank
FROM Employee


-- difference between rank , Dense_Rank and Row_Number 

Select name, gender, salary,
ROW_NUMBER () OVER (ORDER BY Salary DESC) AS RowNumber,
RANK() OVER (ORDER BY salary DESC) AS [Rank],
DENSE_RANK() OVER (ORDER BY Salary desc) AS DensRank
FROM Employee

 
 --calculating running total
 select name,gender,salary,
 sum(salary)  over (order by id) as running_total
 from employee

 --partition by gender 
 select name,gender,salary,
 sum(salary)  over (partition by gender order by id) as running_total
 from employee

 --taking total data from table and with running total
  Select * ,
   sum(salary)  over (partition by gender order by id) as running_total
  from employee


  --NTILE FUNCTION(use to grouping data)
  Select name , gender, salary,
  NTILE (2) OVER (Partition by gender ORDER BY Salary) as [NTILE]
  from Employee
  



  --lead and lag function

  --lead used to access subsequent row data along with current row data
  --Lag used to acess previouse row data along with current row data
  --order by clause is required
  --Partition by clause is optional

  Select name,gender,salary,
  LEAD(salary) OVER (ORDER BY salary) as LEAD,
  LAG(salary) OVER (ORDER BY salary ) AS LAG
  FROM Employee


    Select name,gender,salary,
  LEAD(salary,2,-1) OVER (PARTITION BY Gender ORDER BY salary) as LEAD,
  LAG(salary,2,-1) OVER (ORDER BY salary ) AS LAG
  FROM Employee



  --FIRST VALUE FUNCTION 
  Select name,gender,salary,
  FIRST_VALUE(NAME) OVER (ORDER BY Salary) AS FirstValue
  from Employee


  --using partition by cause
  Select name,gender,salary,
  FIRST_VALUE(NAME) OVER (partition by gender ORDER BY Salary) AS FirstValue
  from Employee

     

--last value function
  Select name,gender,salary,
  LAST_VALUE(NAME) OVER (ORDER BY gender) AS LastValue
  from Employee

--difference between rows and range

Select name, salary,
sum(salary) 
OVER 
(ORDER BY Salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW )
AS RunningTotal
FROM Employee


Select name, salary,
sum(salary) 
OVER 
(ORDER BY Salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW )
AS RunningTotal
FROM Employee










Create Table tblSales 
(
SalesAgent nvarchar(50),
Country nvarchar(30),
SalesAmount int
)

insert into tblSales
values
('David','India',960),
('David','US',800),
('David','UK',1000),
('John','India',1100),
('John','US',600),
('John','UK',2000)

select * from tblsales


--Pivot Operator (Converting rows into column)

Select SalesAgent,India,US,UK
from tblSales
PIVOT
(
		SUM(SalesAmount)
		FOR Country IN (India,US,UK)
) AS PivotExample


--second example (converting name into column)
Select country,David,John 
from tblSales
PIVOT
(
		SUM(SalesAmount)
		FOR SalesAgent In (david,john)
) AS pivotExample 



--Choose function in sql server
-- Return the item at the specified index from the list of available values
--The index position start at 1 and NOTO(ZERO)
SELECT * FROM tblSales

SELECT CHOOSE(2,'india','uk','us') as Country

--real life example of CHOOSE  (Finding the month from DOB)

select * from Transcend

Select Empname,DOB ,
choose (datepart(mm,DOB),'jan','Feb','Mar','Apr','May','Jun','July','Aug','Sep','Oct','Nov','Dec') 
as Month
from transcend




--IIF Function 
--Return one of two the value depending on the boolean expression
--IIF is a shorthand way for writing a CASE expression

Declare @gender int
Set @gender = 2
Select IIF(@gender = 1, 'Male' , 'Female' ) as Gender



--Try_Parse Function
--converts the string into date/time or numeric type
--Returns null if not converted

SELECT TRY_PARSE('25/03/2001' AS datetime) AS Result



--TRY_CONVERT
--CONVERT DATATYPES
SELECT TRY_CONVERT(INT,'99')


--EOMONTH (End of Month)
--return the last day of the specified month
Select EOMONTH('11/20/2012') AS LastDay   --2012-11-30 (30 is last day of month 11)
Select EOMONTH('01/20/2021', -1) AS LastDay  --here it will substract 1 month from given date



--DATEFROMPARTS FUNCTION
--DATEFROMPARTS(year,month,day)
Select DATEFROMPARTS(2001,03,25) as [DATE] --2001-03-25


-- difference between DATETIME and SMALLDATETIME
--DATETIME  -- 11/22/2013 12:35:35.99
--SMALLDATETIME  --11/22/2013



-- DateTime2FromParts function
--Required 8 parameter

select DateTime2FromParts(2013,11,03,12,35,35,0,0) as DateTime2
Select DATETIME2FROMPARTS(2003,03,11,12,15,45,4,4) as dateTime2



--Difference between DateTime and dateTime2 



--Offset Fetch next in sql server
--OFFSETFETCH returns a page of results from the result set
--Order by clause is required
select * from Employee

Select * from Employee
Order by Id
OFFSET @left ROWS
FETCH NEXT @take ROWS ONLY

--creating stored procedure for above OFFSETFETCH NEXT
create proc FN_LI_TI
@left int,
@take int
as
begin
Select * from Employee
Order by Id
OFFSET @left ROWS
FETCH NEXT @take ROWS ONLY
end

execute FN_LI_TI 3,3




--How to identify Object Dependencies 
Select * from sys.dm_sql_referencing_entities('Employee', 'objects')

Select * from sys.dm_sql_referenced_entities('dbo.FN_LI_TI', 'Objects')


--SP_DEPENDS
execute SP_DEPENDS 'FN_LI_TI'